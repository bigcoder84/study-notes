# 数组

## 一. 数组的声明和初始化

数组是所有语言编程中最常用的数据结构之一，Go 语言也不例外，与 PHP、JavaScript 等弱类型动态语言不同，在 Go 语言中，数组是固定长度的、同一类型的数据集合。数组中包含的每个数据项被称为数组元素，一个数组包含的元素个数被称为数组的长度。

在 Go 语言中，你可以通过 `[]` 来标识数组类型，但需要指定长度和元素类型。以下是一些常见的数组声明方法：

```go
var a [8]byte // 长度为8的数组，每个元素为一个字节
var b [3][3]int // 二维数组（9宫格）
var c [3][3][3]float64 // 三维数组（立体的9宫格）
var d = [3]int{1, 2, 3}  // 声明时初始化
var e = new([3]string)   // 通过 new 初始化
```

从以上示例可以看出，数组也可以是多维的。和普通变量赋值一样，数组也可以通过 `:=` 进行一次性声明和初始化，所有数组元素通过 `{}` 包裹，然后通过逗号分隔多个元素：

```go
a := [5]int{1,2,3,4,5}
```

总结一下，数组的格式定义如下所示：

```go
[容量]数据类型{数组元素}
```

此外，还可以通过这种语法糖省略数组长度的声明：

```go
a := [...]int{1, 2, 3}
```

这种情况下，Go 会在编译期自动计算出数组长度。

数组在初始化的时候，如果没有填满，则空位会通过对应的元素类型零值填充：

```go
a := [5]int{1, 2, 3}
fmt.Println(a) //打印 [1 2 3 0 0]
```

数组长度在声明后就不可更改，在声明时可以指定数组长度为一个常量或者一个常量表达式（常量表达式是指在编译期即可计算结果的表达式）。数组的长度是该数组类型的一个内置常量，可以用 Go 语言的内置函数 `len()` 来获取：

```go
arrLength := len(arr)
```

## 二. 数组元素的访问和设置

可以使用数组下标来访问 Go 数组中的元素，数组下标默认从 0 开始，`len(arr)-1` 表示最后一个元素的下标：

```go
arr := [5]int{1,2,3,4,5}
a1, a2 := arr[0], arr[len(arr) - 1]
```

上面 `a1` 的值是 `1`，`a2` 的值是 `5`。

访问数组元素时，下标必须在有效范围内，比如对于一个长度为 5 的数组，下标有效范围是 0~4，超出这个范围编译时会报索引越界异常：

```txt
invalid array index 5 (out of bounds for 5-element array)
```

和字符串这种不可变值类型不一样，数组除了支持通过下标访问对应索引的元素值之外，还可以通过下标设置对应索引位置的元素值：

```go
arr[0] = 100
```

数组可以使用切片操作，Go 切片区间可以对比数学中的区间概念来理解，它是一个**左闭右开**的区间:

```go
t := arr[1:3] //返回 [2,3]
```

## 三. 数组类型的不足

由于数组类型变量一旦声明后长度就固定了，这意味着我们将不能动态添加元素到数组，如果要这么做的话，需要先创建一个容量更大的数组，然后把老数组的元素都拷贝过来，最后再添加新的元素，如果数组尺寸很大的话，势必会影响程序性能。

另外，**数组是值类型（关于值类型和引用类型，后面在 Go [类型系统](https://geekr.dev/posts/go-type-system)中会详细介绍），这意味着作为参数传递到函数时，传递的是数组的值拷贝，也就是说，会先将数组拷贝给形参，然后在函数体中引用的是形参而不是原来的数组，当我们在函数中对数组元素进行修改时，并不会影响原来的数组，这种机制带来的另一个负面影响是当数组很大时，值拷贝会降低程序性能**。

综合以上因素，我们迫切需要一个引用类型的、支持动态添加元素的新「数组」类型，这就是下篇教程将要介绍的切片类型，实际上，我们在 Go 语言中很少使用数组，大多数时候会使用切片取代它。