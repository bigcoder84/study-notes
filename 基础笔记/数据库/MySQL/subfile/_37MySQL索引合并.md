# MySQL索引合并

## 一. 前言

先问大家一个问题，在不考虑多表联查这种复杂的查询场景下，一个简单的单表查询，MySQL可以同时利用几个索引？ 

当初我学习MySQL的时候，天真的以为只要把`WHERE`条件涉及到的列全部加上索引，就可以提升查询速度，这个想法其实大错特错。因为一般情况下，单表查询MySQL只能利用一个索引，比如下面这个查询，假设id是主键，a和b分别创建了索引，别天真的以为`idx_a`和`idx_b`都能发挥作用，其实不是的。

```sql
SELECT id,a,b FROM T WHERE a>100 AND b>200;
```

因为`idx_a`索引只存储了列a和id的值，无法判断`b>200`条件是否成立，所以只能拿着id去回表查询。同样`idx_b`索引只存储了列b和id的值，无法判断`a>100`条件是否成立，也只能拿着id去回表查询。可以看到，最大的开销其实是回表操作，通过二级索引匹配到的数据越少，回表的开销也就越低。所以理论上来说，`a>100`和`b>200`分别符合这两个条件的记录数越少，MySQL就会使用哪个索引。MySQL是如何判断符合这些条件的记录数量的呢？不也得老老实实的扫描全表吗？MySQL采用预估的方式，通过表的统计数据或访问表中少量的数据来进行预估，并分别计算使用这两个索引进行查询各自的成本是多少，最终选择执行成本更低的索引方案。关于MySQL如何预估执行成本，不在本篇文章的讨论范围内，具体逻辑可参考：[MySQL索引选择](./_23MySQL索引选择.md)。 

我们假设最终MySQL使用`idx_a`索引，那么这个查询过程其实是这样的：

1. InnoDB从`idx_a`B+树中获取到第一条`a>100`的记录，拿记录里的id值回表查询。
2. 回表查询获取到完整的用户记录，判断`b>200`是否成立，成立则返回给客户端，否则丢弃该记录。
3. InnoDB继续从`idx_a`B+树中获取到下一条`a>100`的记录，重复前面的过程。

建立了这么多索引，每次查询只使用一个，太可惜了不是嘛。能不能同时利用多个索引来完成查询呢？可以的，但是条件有些严苛，这就是我们今天要介绍的索引合并Index Merge。

## 二. Index Merge

MySQL将这种使用多个索引来完成一次查询的执行方法称为 索引合并「index merge」。如何才能知道我们写的SQL语句使用了索引合并呢？通过`EXPLAIN`分析一下就知道了，如果使用了索引合并，对应的`type`列显示的值应该是`index_merge`，`key`列显示用的到所有索引名称，`Extra`列会显示具体使用了哪种类型的索引合并。 如下所示，同时使用了`idx_a`和`idx_b`两个索引完成查询，且索引合并类型为`Intersection`。

| **table** | **type**    | **key**     | **Extra**                                              |
| --------- | ----------- | ----------- | ------------------------------------------------------ |
| T         | index_merge | idx_a,idx_b | Using intersect(idx_a,idx_b); Using where; Using index |

什么？索引合并还分类型？是的，MySQL目前共支持三种类型的索引合并，分别是：

| **索引合并类型** | **说明**                                                   |
| ---------------- | ---------------------------------------------------------- |
| Intersection     | 对多个二级索引里符合条件的主键值取交集合并                 |
| Union            | 对多个二级索引里符合条件的主键值去重后取并集合并           |
| Sort Union       | 对多个二级索引里符合条件的主键值去重并排序后，再取并集合并 |

我们使用一个具体的例子，来分别演示下三种索引合并。假设有表T如下，id是主键，列a和列b分别创建索引。

```sql
CREATE TABLE T(
    `id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `a` INT NOT NULL,
    `b` CHAR(1) DEFAULT NULL,
    KEY `idx_a` (a) USING BTREE,
    KEY `idx_b` (b) USING BTREE
)ENGINE=InnoDB AUTO_INCREMENT=1;
```

大家可以写个存储过程，向表中批量插入记录，我这里贴一下代码，写的很简陋。

```sql
CREATE PROCEDURE insertT()
BEGIN
    DECLARE i INT DEFAULT 0;
    START TRANSACTION;
        WHILE i<=10000 do
            INSERT INTO T (a, b) VALUES (i,CHAR(rand()*(90-65)+65));
            SET i=i+1;
        END WHILE;
    COMMIT;
END;
call insertT();
```

列a和列b均是普通索引，值是允许重复的，大家可以多调用几次存储，最终的数据就是：a的值在一万以内重复，b的值在`A~Z`之间重复，主键保持递增。下面我们基于这张表的数据来演示。

### 2.1 Intersection（交集）

```sql
SELECT * FROM T WHERE a=1 AND b='A';
```

针对这个查询，目前我们知道它可以有以下三种查询方式：

1. 全表扫描，判断两个条件是否匹配。
2. 利用`idx_a`索引将获取到id回表查询再判断条件b是否达成。
3. 利用`idx_b`索引将获取到id回表查询再判断条件a是否达成。

有了Intersection索引合并，MySQL其实还可以有第四种查询方式，查询过程是这样的：

1. 利用`idx_a`索引将获取到的id集合记作`id_setA`。
2. 利用`idx_b`索引将获取到的id集合记作`id_setB`。
3. 将`id_setA`和`id_setB`取交集，记作`id_set`。
4. 对`id_set`回表查询，将结果返回给客户端。

这个过程描述的其实是有问题的，但是大概意思是对的，主要是帮助大家理解。对id取交集的过程，并不是这样的，本质上MySQL并不会存储这些id集合，因为数据量一大是很占用内存的，这个我们待会说。 

综上所述，这种通过从多个索引中扫描到的记录的主键值取交集后再回表查询的方式，就是Intersection索引合并。`EXPLAIN`分析结果如下：

```shell
mysql> EXPLAIN SELECT * FROM T WHERE a=1 AND b='A';
+----+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+--------------------------------------------------------+
| id | select_type | table | partitions | type        | possible_keys | key         | key_len | ref  | rows | filtered | Extra                                                  |
+----+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+--------------------------------------------------------+
|  1 | SIMPLE      | T     | NULL       | index_merge | idx_a,idx_b   | idx_a,idx_b | 4,4     | NULL |    1 |   100.00 | Using intersect(idx_a,idx_b); Using where; Using index |
+----+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+--------------------------------------------------------+
```

需要注意的是，使用Intersection索引合并是有条件的。**如果使用到的索引都是二级索引的话，则要求通过二级索引取出的记录是按照主键排好序的**。为什么会有这个要求呢？主要是有以下两个好处：

- 对两个有序集合取交集更简单。
- 主键有序的情况下，回表将不再是单纯的随机IO，回表的效率更高。

很显然，我们这个查询是能利用Intersection索引合并的。`idx_a`索引中是先根据a排序再根据id排序的，`a=1`的情况下，取出的记录是按照id排好序的。`idx_b`索引中是先根据b排序再根据id排序的，`b='A'`的情况下，取出的记录也是按照id排好序的。所以是符合要求的。 

最后，我们看一下MySQL从两个集合中取交集的过程。假设`idx_a`过滤出的id是`[1,3,5]`，`idx_b`过滤出的id集合是`[2,3,4]`，取交集的过程其实是这样的：

1. 从`idx_a`取出第一条记录，id值是1。再从`idx_b`取出第一条记录，id值是2，因为`1<2`所以id为1的那条记录直接丢弃。
2. 从`idx_a`取出第二条记录，id值是3，因为`2<3`，所以id为2的那条记录直接丢弃。
3. 从`idx_b`取出第二条记录，id值是3，因为`3=3`，所以拿3去回表查询，结果返回给客户端，同时id为3的两条记录也直接丢弃。
4. 从`idx_a`取出第三条记录，id值是5。从`idx_b`取出第三条记录，id值是4。因为`4<5`所以id为4的记录被丢弃，又因为双方都没有记录了，id为5的记录也被丢弃，交集过程结束。

通过上述过程，现在你应该很清楚为啥MySQL要求二级索引返回的记录必须根据主键排好序了吧，如此一来，整个求交集的过程将变得非常简单，MySQL也无需使用额外的内存空间来保存这些id集合。

### 2.2 Union（并集）

```sql
SELECT * FROM T WHERE a=1 OR b='A';
```

针对这个查询，我们是无法单独使用`idx_a`或`idx_b`索引来完成的，因为它们的条件关系是`OR`，目前我们已知的查询方式就一种：

1. 全表扫描，判断两者条件满足其一就返回给客户端。

这种方式很明显太笨了，有了Union索引合并，MySQL其实可以有第二种查询方式，过程是这样的：

1. 利用`idx_a`索引将获取到的id集合记作`id_setA`。
2. 利用`idx_b`索引将获取到的id集合记作`id_setB`。
3. 将`id_setA`和`id_setB`取并集，记作`id_set`。
4. 对`id_set`回表查询，将结果返回给客户端。

这个过程和Intersection其实很像，只是交集换成了并集而已，所以很好理解。同样的，取并集的过程也并非如此，这里只是方便大家理解。 

综上所述，这种通过从多个索引中扫描到的记录的主键值取并集后再回表查询的方式，就是Union索引合并。`EXPLAIN`分析结果如下：

```shell
mysql> EXPLAIN SELECT * FROM T WHERE a=1 OR b='A';
+----+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table | partitions | type        | possible_keys | key         | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | T     | NULL       | index_merge | idx_a,idx_b   | idx_a,idx_b | 4,4     | NULL | 1016 |   100.00 | Using union(idx_a,idx_b); Using where |
+----+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+---------------------------------------+
```

同样，使用Union索引合并也是有条件的。**如果使用到的索引都是二级索引的话，则要求通过二级索引取出的记录是按照主键排好序的**。为什么会有这个要求呢？主要是有以下两个好处：

- 对两个有序集合取并集更简单。
- 主键有序的情况下，回表将不再是单纯的随机IO，回表的效率更高。

Union索引合并取并集的过程，和Intersection也很像。MySQL依然不需要使用额外的内存存储这些id集合，大家可以按照上述流程自己走一遍，这里不再赘述。

### 2.3 Sort Union

```sql
SELECT * FROM T WHERE a=1 OR b>='Z';
```

针对这个查询，是不能使用Union索引合并的，因为它不满足条件：从`idx_b`二级索引取出的记录并非是按照主键排序的。所以目前我们已知的查询方式就一种：

1. 全表扫描，判断两者条件满足其一就返回给客户端。

Intersection和Union使用的条件很严苛，必须要求二级索引取出的记录是按照主键排好序的，针对这个查询无法使用。但是这两个条件`a=1`和`b>='Z'`很大概率能过滤掉大部分记录，是可以提升查询效率的，怎么办呢？

MySQL很想利用这两个索引，于是想了个办法。既然二级索引自然取出来的主键不是排好序的，那我就先放到内存里自己排好序再使用Union的方式去查询。整个过程是这样的：

1. 先从`idx_b`索引中取出所有符合条件记录，提取id集合先去重再排序，记作`id_setB`。
2. 此时`id_setB`已经是有序的了，从`idx_a`中依次取出记录的id值，走正常取并集的过程即可。
3. 对最终的id并集回表，将结果返回给客户端。

综上所述，这种通过从多个索引中扫描到的记录的主键值排好序后，再按照Union索引合并的方式执行查询的方式，就是Sort Union索引合并。相较于Union，其实就是多了一个对主键手动排序的过程。`EXPLAIN`分析结果如下：

```shell
mysql> EXPLAIN SELECT * FROM T WHERE a=1 OR b>='Z';
+----+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+--------------------------------------------+
| id | select_type | table | partitions | type        | possible_keys | key         | key_len | ref  | rows | filtered | Extra                                      |
+----+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+--------------------------------------------+
|  1 | SIMPLE      | T     | NULL       | index_merge | idx_a,idx_b   | idx_a,idx_b | 4,4     | NULL |  975 |   100.00 | Using sort_union(idx_a,idx_b); Using where |
+----+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+--------------------------------------------+
```

### 2.4 Sort Intersection

很遗憾，目前MySQL并不支持所谓的“Sort Intersection”索引合并的方式。大家肯定很好奇，既然有Sort Union，为啥没有Sort Intersection呢？不就是先手动排序再取交集吗？ 

没有查找到相关资料解释为啥不支持，我可以说下我的理解。大家可以想一下，交集的本质是什么？一般情况下是将两个很大的集合，变成一个较小的集合。而并集的本质又是什么呢？一般情况下是将两个较小的集合，变成一个较大的集合。 

大家明白了吗？对两个较小的集合在内存中排序，开销可以接受。但是对两个较大的集合在内存中完成排序，这个操作本身的开销可能比回表的开销都大了，那MySQL还不如只利用「单索引+回表」的方式查询呢。

## 三. 索引合并的一些思考

### 3.1 索引合并的意义

在AND组合条件中，选择Index Merge进行intersection，每个索引都要扫描一遍再取交集，扫描行数明显会变多，但取交集后结果集会变少，能`减少回表的开销`。若多个索引组合起来能覆盖所有访问的列，就变成了覆盖索引，可以直接避免回表。 在OR组合条件中，如果不选Index Merge，就只能全表扫描了，通过扫描多个索引取并集，可以`避免全表扫描`。

Index Merge原理是通过扫描多个索引，将各索引扫描的数据进行合并（交集、并集），预期是更快的计算出目标结果。比如intersection方式在合并后能减少回表的次数，甚至多个索引组合成覆盖索引可直接避免回表，大幅提升性能；Union方式通过扫描多个索引进行并集合并，避免扫描全表从而提升效率。

### 3.2 索引合并并不一定都是正向优化

**Index Merge并不总是能提升性能，比如intersection中，多个索引扫描的数据重叠路非常高，合并取交集并不会减少found_rows，这样既没有减少回表次数，又额外增加了N多个索引的扫描，开销反而增加了**。再比如Union中，若多个OR条件的扫描行数都很大，加起来扫描行数可能比全表rows都要大，就不如直接扫全表了。所以基于代价的选择Index Merge成为了影响查询性能的关键:

- Intersection代价，关键在计算索引合并后的out_rows，也就是合并后的交集选择率乘数。 
- Union的代价相对简单些，主要是将多个索引扫描的代价累加

Intersection的Index Merge在线上出现慢查的频率最高，主要问题出在索引合并选择率乘数的计算上，它是基于非相关性假设计算的。若真实业务数据两列存在较大的相关性，既两个索引扫描出的数据有大量重叠，这样两个索引相交后out_rows比预期要大很多，但代价计算中无法识别列间的相关性，**估算的Index Merge代价通常会偏小，导致错选Index Merge引发慢查询**。

例如生产环境中曾经遇到过，索引设计不合理，导致MySQL查询优化器使用索引合并优化查询返回增加了查询时间的问题。当时查询语句如下：
```sql
select 
  oss_path 
from 
  table_name 
where 
  `status` = 2 
  and user_id = 123
```

表中除了主键外，还为status 字段和 user_id 字段分别建立了二级索引。经过观察这类 SQL 的执行计划有两种：

- SQL 偶发会使用 index_merge 通过使用两个字段的索引过滤，然后取交集，再返回数据，耗时 120 秒。
- SQL 会使用 user_id 字段的索引进行过滤，耗时 50ms。

由于 status 索引选择性很低，所以通过 `status=2` 查询出来的主键数量很大，而索引合并取交集时，由于 `user_id=123` 查询出来的主键ID 和 status=1查询出来的主键ID重叠率很高，那么实际上索引合并中查询status=2的数据并没有减少太多的回表数据量，反而需要增加非常多 status=2 的数据扫描成本。

优化器选择索引合并导致查询变慢的原因

- 统计信息不准确：
  - 优化器是基于统计信息计算的各个索引查询策略的成本，但是统计信息可能不准确。如果优化器认为通过索引合并可以减少需要扫描的行数，从而降低 I/O 成本，它可能会选择索引合并。但实际上，**由于统计信息的偏差，可能导致它高估了索引合并的优势**。例如，它可能错误地估计了每个索引中符合条件的行数，使得它认为使用索引合并后总的扫描行数会更少。
- 成本估算模型的局限性：
  - MySQL 的成本估算模型是基于一定的假设和规则的。它可能无法准确地考虑到所有实际情况中的开销。例如，它可能没有充分考虑到索引合并操作本身的 CPU 成本和临时结果集的 I/O 成本。在复杂的查询场景下，这些成本可能会对查询性能产生重大影响。
- 数据分布的影响：
  - 数据的分布情况也会影响优化器的决策。如果数据在索引中的分布不均匀，优化器基于统计信息做出的决策可能会不准确。例如，`status`和`user_id`两个字段对应的索引，在某些值的组合下可能导致索引合并的效果很差。假设 `user_id = 123` 的记录大部分都符合 `status = 2` 的条件，那么使用索引合并取交集的操作并不会降低回表查询的数据量，反而还会扫描大量status索引不必要的数据。

选错索引合并策略致使查询变慢，其根本原因在于：因统计信息存在偏差，优化器过高地估计了索引合并的优势。具体而言，这里的高估是指优化器高估了在进行索引合并操作后所能降低的回表工作量，同时又低估了索引合并自身所增加的工作量。

> 本文参考：
>
> [MySQL优化之Index Merge1. 前言 先问大家一个问题，在不考虑多表联查这种复杂的查询场景下，一个简单的单表 - 掘金](https://juejin.cn/post/7071865447108313095)
>
> [MySQL Index-Merge代价估算原理](http://mysql.taobao.org/monthly/2024/09/04/)



