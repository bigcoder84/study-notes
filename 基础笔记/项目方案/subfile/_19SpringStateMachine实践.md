# Spring State Machine入门实践

## 一. 状态机

### 1.1 什么是状态

先来解释什么是`状态（ State ）`。现实事物是有不同状态的，例如一个自动门，就有 `open` 和 `closed` 两种状态。我们通常所说的状态机是有限状态机，也就是被描述的事物的状态的数量是有限个，例如自动门的状态就是两个 `open` 和 `closed` 。

状态机，也就是 `State Machine` ，不是指一台实际机器，而是指一个数学模型。说白了，一般就是指一张状态转换图。

状态机的全称是`有限状态自动机`，自动两个字也是包含重要含义的。给定一个状态机，同时给定它的当前状态以及输入，那么输出状态时可以明确的运算出来的。例如对于自动门，给定初始状态 closed ，给定输入“开门”，那么下一个状态时可以运算出来的。

### 1.2 状态机中的概念

下面来给出状态机的四大概念：

- `State`：状态，一个状态机`至少`要包含两个状态。
- `Event`：事件，事件就是执行某个操作的触发条件或者口令。对于自动门，“按开门按钮”就是一个事件。
- `Action`：动作，事件发生以后要执行动作。例如事件是“按开门按钮”，动作是“开门”。编程的时候，一个 Action一般就对应一个函数。
- `Transition`：变换，也就是从一个状态变化为另一个状态。例如“开门过程”就是一个变换。

### 1.3 状态机

`有限状态机（Finite-state machine,FSM）`，又称`有限状态自动机`，简称`状态机`，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。

`FSM`是一种算法思想，简单而言，有限状态机由一组状态、一个初始状态、输入和根据输入及现有状态转换为下一个状态的转换函数组成。
其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。

## 二. 状态机选型

### 2.1 Spring StateMachine

Spring StateMachine 是 Spring 官方提供的状态机实现。

先从状态机的定义入手，StateMachine<States, Events>，其中：

- StateMachine：状态机模型
- State：S-状态，一般定义为一个枚举类，如创建、待风控审核、待支付等状态
- Event：E-事件，同样定义成一个枚举类，如订单创建、订单审核、支付等，代表一个动作。一个状态机的定义就由这两个主要的元素组成，状态及对对应的事件（动作）。

Spring StateMachine 中的相关概念：

- Transition: 节点，是组成状态机引擎的核心
- Source：节点的当前状态
- Target：节点的目标状态
- Event：触发节点从当前状态到目标状态的动作
- Guard：起校验功能，一般用于校验是否可以执行后续 Action
- Action：用于实现当前节点对应的业务逻辑处理

以下是一些核心组件：

![](../images/45.png)

### 2.2 Cola StateMachine

Spring StateMachine是有状态的（Stateful）的，有状态意味着多线程并发情况下如果是单个实例就容易出现线程安全问题。

如今我们的系统普遍都是分布式部署，不得不考虑多线程的问题，因为每来一个请求就需要创建一个状态机实例(per statemachine per request)。如果某些状态机它的构建过程很复杂，并且当下 QPS 又很高的话，往往会造成系统的性能瓶颈。

为此阿里出了一个开源的状态机：**Cola-StateMachine**

Cola-StateMachine 最重要的特点是，**状态机的设计是无状态的，并且内部实现了 DSL 语法，通过流式 API 限定了方法调用的顺序。**

![](../images/46.png)

分析一下市面上的开源状态机引擎，不难发现，它们之所以有状态，主要是在状态机里面维护了两个状态：初始状态（Initial State）和当前状态（Current State），如果我们能把这两个实例变量去掉的话，就可以实现无状态，从而实现一个状态机只需要有一个 Instance 就够了。

关键是这两个状态可以不要吗？当然可以，唯一的副作用是，我们没办法获取到状态机 Instance 的 Current State。然而，我也不需要知道，因为我们使用状态机，仅仅是接受一下 Source State，Check 一下 Condition，Execute 一下 Action，然后返回 Target State 而已。它只是实现了一个状态流转的 DSL 表达，仅此而已，全程操作完全可以是无状态的。

具体举例如下：

```java
        // 构建一个状态机(生产场景下，生产场景可以直接初始化一个Bean)
        StateMachineBuilder<StateMachineTest.ApplyStates, StateMachineTest.ApplyEvents, Context> builder = StateMachineBuilderFactory.create();
        // 外部流转(两个不同状态的流转)
        builder.externalTransition()
            .from(SOURCE)//原来状态
            .to(TARGET)//目标状态
            .on(EVENT1)//基于此事件触发
            .when(checkCondition1())//前置过滤条件
            .perform(doAction());//满足条件，最终触发的动作
```

### 2.3 有状态VS无状态

有状态状态机（Stateful State Machine）：状态机内部维护当前状态，每次事件触发后自动更新状态，无需外部显式传递当前状态。

**优点**：

1. **简化调用逻辑**
   调用方只需传递事件（Event），无需管理当前状态，状态变更由状态机内部自动处理，代码更简洁。
2. **状态生命周期可控**
   状态机可以管理状态的初始化、持久化和销毁逻辑，适合需要长期跟踪状态的场景（如订单流程、审批流）。
3. **适合复杂流程**
   天然支持状态持久化和恢复，适用于需要处理异步事件、状态回溯或长时间运行流程的场景。
4. **框架集成友好**
   如 Spring State Machine 等框架提供了开箱即用的状态管理、监听器和持久化机制。

**缺点**：

1. **状态共享问题**
   在并发或分布式环境中，多个实例可能同时修改同一状态，需要额外处理线程安全或分布式锁。在用户交互场景下，通常需要为每一个用户会话创建一个独立的状态机实例以避免并发问题，这样状态机实例的初始化开销+GC开销可能会不如无状态状态机。
2. **资源占用**
   每个状态机实例需要维护自身状态，可能占用较多内存（尤其在大量并发场景中）。
3. **持久化复杂度**
   若状态需要持久化到数据库或外部存储，需要处理状态序列化和恢复逻辑，增加复杂度。

### 2.4 功能对比

![](../images/47.png)

持久化一方面是好事，另一方面是坏事。

好事是因为持久化策略可以应对分布式系统的故障，每个实体对象在做状态变迁之前，可以从持久化的存储中获取该实体之前的状态，不用担心状态的丢失。

坏事是因为为了要保证状态机的状态，每次状态变迁之前都需要先恢复当前的状态，这个操作是非常消耗性能的。

Cola StateMachine 将 StateMachine 的实例定义为无状态(Stateless)的，状态的变迁不依赖当前 StateMachine 实例的状态，所以也就不需要持久化的问题。系统发生故障时，StateMachine 的实例也不需要重建，只需要对状态变迁做重试即可，状态是否能够变迁是在 Condition 中定义的，跟 StateMachine 的实例没有直接的关系。

### 2.5 接入成本对比

![](../images/48.png)

## 三. Spring StateMachine Demo

















> 参考文章：
>
> [得物商品状态体系介绍](https://tech.dewu.com/article?id=91)
>
> [Spring之状态机讲解 - 上善若泪 - 博客园](https://www.cnblogs.com/jingzh/p/17443862.html)
>
> [Spring State Machine（状态机）入门 - spring 中文网](https://springdoc.cn/spring-state-machine-guides/)